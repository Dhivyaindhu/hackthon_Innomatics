# -*- coding: utf-8 -*-
"""Hackthon Participation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tAS6VN1XFTsCtt6x-7KaP-_UCj0a8Rrp
"""

import numpy as np
import pandas as pd
data=pd.read_csv('/content/zomato_data.csv')
print(data.head())
print(data.shape)
df = data.dropna(subset=['cuisines'])

# Split multiple cuisines and count frequency
from collections import Counter

# Create a list of all cuisines
cuisine_list = df['cuisines'].str.split(', ').sum()
cuisine_counts = Counter(cuisine_list)

# Get the most common cuisines
most_common_cuisines = cuisine_counts.most_common(10)

# Display the top cuisines
for cuisine, count in most_common_cuisines:
    print(f"{cuisine}: {count}")

import pandas as pd

# Load the dataset
df = pd.read_csv("/content/zomato_data.csv", encoding="latin-1")

# Filter only online orders
online_orders = df[df['online_order'] == 'Yes']

# Total online orders
total_online = len(online_orders)

# Online orders in Banashankari
banashankari_online = online_orders[online_orders['listed_incity'] == 'Banashankari']
banashankari_count = len(banashankari_online)

# Calculate percentage
percentage = (banashankari_count / total_online) * 100

print(f"Banashankari receives {percentage:.2f}% of all online orders.")

import pandas as pd

# Load the dataset
df = pd.read_csv("/content/zomato_data.csv", encoding="latin-1")

# Clean up whitespaces and casing (optional but recommended)
df['online_order'] = df['online_order'].str.strip().str.lower()
df['listed_incity'] = df['listed_incity'].str.strip().str.lower()

# Filter only online orders
online_orders = df[df['online_order'] == 'yes']

# Total online orders
total_online = len(online_orders)

# Online orders in Banashankari
banashankari_online = online_orders[online_orders['listed_incity'] == 'banashankari']
banashankari_count = len(banashankari_online)

# Calculate percentage
percentage = (banashankari_count / total_online) * 100

print(f"Banashankari receives {percentage:.2f}% of all online orders.")

import pandas as pd

# Load the dataset
df = pd.read_csv('/content/zomato_data.csv', encoding='latin-1')

# Clean whitespace
df['listed_incity'] = df['listed_incity'].str.strip()
df['rest_type'] = df['rest_type'].str.strip()

# Group by locality and count unique restaurant types
diversity = df.groupby('listed_incity')['rest_type'].nunique().sort_values(ascending=False)

# Show top 5 diverse localities
print("Top localities by restaurant type diversity:")
print(diversity.head())

# If you want to check specific options given in MCQ:
options = ['Brigade Road', 'BTM', 'Bannerghatta Road', 'Brookefield']
for opt in options:
    count = diversity.get(opt, 0)
    print(f"{opt}: {count} unique restaurant types")

import pandas as pd

# Load the dataset
df = pd.read_csv('/content/zomato_data.csv', encoding='latin-1')

# Clean and prepare the cost column
df['approx_costfor_two_people'] = df['approx_costfor_two_people'].astype(str)
df['approx_costfor_two_people'] = df['approx_costfor_two_people'].str.replace(',', '')
df['approx_costfor_two_people'] = pd.to_numeric(df['approx_costfor_two_people'], errors='coerce')

# Standardize rest_type for filtering
df['rest_type'] = df['rest_type'].str.strip().str.lower()

# Filter buffet and delivery restaurants
buffet_df = df[df['rest_type'].str.contains('buffet', na=False)]
delivery_df = df[df['rest_type'].str.contains('delivery', na=False)]

# Calculate average costs
avg_buffet = buffet_df['approx_costfor_two_people'].mean()
avg_delivery = delivery_df['approx_costfor_two_people'].mean()

# Calculate difference
cost_difference = avg_buffet - avg_delivery

print(f"Average Buffet Cost: ₹{avg_buffet:.2f}")
print(f"Average Delivery Cost: ₹{avg_delivery:.2f}")
print(f"Average Cost Difference: ₹{cost_difference:.2f}")

import pandas as pd

# Load the dataset
df = pd.read_csv('/content/zomato_data.csv', encoding='latin-1')

# Clean the cost column
df['approx_costfor_two_people'] = df['approx_costfor_two_people'].astype(str)
df['approx_costfor_two_people'] = df['approx_costfor_two_people'].str.replace(',', '')
df['approx_costfor_two_people'] = pd.to_numeric(df['approx_costfor_two_people'], errors='coerce')

# Standardize rest_type for filtering
df['rest_type'] = df['rest_type'].str.strip().str.lower()

# Filter buffet and delivery restaurants
buffet_df = df[df['rest_type'].str.contains('buffet', na=False)].copy()
delivery_df = df[df['rest_type'].str.contains('delivery', na=False)].copy()

# Check for non-null values before proceeding
valid_buffet = buffet_df['approx_costfor_two_people'].dropna()
valid_delivery = delivery_df['approx_costfor_two_people'].dropna()

# Check counts
print(f"Valid Buffet Entries: {len(valid_buffet)}")
print(f"Valid Delivery Entries: {len(valid_delivery)}")

# Calculate averages only if data exists
if len(valid_buffet) > 0 and len(valid_delivery) > 0:
    avg_buffet = valid_buffet.mean()
    avg_delivery = valid_delivery.mean()
    cost_difference = avg_buffet - avg_delivery

    print(f"Average Buffet Cost: ₹{avg_buffet:.2f}")
    print(f"Average Delivery Cost: ₹{avg_delivery:.2f}")
    print(f"Average Cost Difference: ₹{cost_difference:.2f}")

    # Choose closest option
    if 200 <= cost_difference < 300:
        print("✔ Closest Option: ₹200-300")
    elif 500 <= cost_difference < 600:
        print("✔ Closest Option: ₹500-600")
    elif 700 <= cost_difference < 800:
        print("✔ Closest Option: ₹700-800")
    elif 800 <= cost_difference < 900:
        print("✔ Closest Option: ₹800-₹900")
    else:
        print("❌ No matching option found.")
else:
    print("⚠ Buffet or Delivery category has no valid cost data.")

!pip install folium

!pip install IPython

df=pd.read_csv('/zomato_data.csv')

import numpy as np
import pandas as pd
from  folium.plugins import MarkerCluster
from IPython.display import IFrame

zomato_df = pd.read_csv("/zomato_data.csv")
geo_df = pd.read_csv("/Geographical Coordinates.csv")  # change filename as needed

print(zomato_df.columns)
print(geo_df.columns)

import pandas as pd
import folium
from IPython.display import IFrame

# Load datasets
zomato_df = pd.read_csv("/zomato_data.csv")
geo_df = pd.read_csv("/Geographical Coordinates.csv")

# Merge on 'listed_incity'
merged_df = pd.merge(zomato_df, geo_df, on='listed_incity', how='left')

# Filter for Italian cuisine
italian_df = merged_df[merged_df['cuisines'].str.contains("Italian", na=False)]

# Create the map centered on Bangalore
map4 = folium.Map(location=[12.9716, 77.5946], zoom_start=12)

# Add purple markers for each Italian restaurant
for _, row in italian_df.iterrows():
    if pd.notnull(row['Latitude']) and pd.notnull(row['Longitude']):
        folium.Marker(
            location=[row['Latitude'], row['Longitude']],
            popup=f"{row['listed_incity']}<br>Cuisine: {row['cuisines']}",
            icon=folium.Icon(color='purple')
        ).add_to(map4)

# Save the map
map4.save("italian_spots_map.html")

# Display the map inside the notebook
IFrame("italian_spots_map.html", width=800, height=500)

map4.save("italian_spots_map.html")
map4

# Provide a download link
from google.colab import files
files.download("italian_spots_map.html")

# Merge datasets on 'listed_incity'
merged_df = pd.merge(zomato_df, geo_df, on='listed_incity', how='left')

# Drop rows without coordinates
merged_df = merged_df.dropna(subset=['Latitude', 'Longitude'])

# Initialize map centered on Bangalore
density_map = folium.Map(location=[12.9716, 77.5946], zoom_start=12)

# Add marker clustering
marker_cluster = MarkerCluster().add_to(density_map)

# Loop and add each restaurant marker
for _, row in merged_df.iterrows():
    folium.Marker(
        location=[row['Latitude'], row['Longitude']],
        popup=folium.Popup(f"""
            <b>City:</b> {row['listed_incity']}<br>
            <b>Rating:</b> {row['rate']}<br>
            <b>Cost for Two:</b> {row['approx_costfor_two_people']}
        """, max_width=250),
        icon=folium.Icon(color='blue', icon='cutlery', prefix='fa')
    ).add_to(marker_cluster)

# Save the map to an HTML file
density_map.save("restaurant_density.html")

# View in Colab (use this instead of IFrame)
density_map